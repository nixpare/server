package server

import (
	"fmt"
	"runtime/debug"
	"strings"
	"sync"
)

// routineError is used by the Logger to log errors occurred during
// a Scheduler routine
type routineError struct {
	err error
	sc  *Scheduler
}

// routinepanic is used by the Logger to log panics occurred during
// a Scheduler routine
type routinePanic struct {
	err   any
	stack string
	sc    *Scheduler
}

// Scheduler can be used to create new goroutine functions that are
// panic-safe, it means that if something wrong happens and that
// goroutines panics, the Scheduler uses the Logger to report the panic
// with a reference to the goroutines involved and writing to the extra
// field the stack dump associated with the panic.
// The scheduler is also meant to be used for background activities that
// may encounter some errors, which are handled by the Logger.
// It has an identifier name included user to log any error or panic (see
// Scheduler.Name)
type Scheduler struct {
	name            string
	depth           int
	m               *sync.Mutex
	parent          *sync.WaitGroup
	child           *sync.WaitGroup
	logWG           *sync.WaitGroup
	waitC           chan struct{}
	exitC           chan struct{}
	mainScheduler   bool
	firstWaitCalled bool
	stopping        bool
	panicChan       chan routinePanic
	errChan         chan routineError
	logger          Logger
}

// NewScheduler creates the main Scheduler that can be used to istanciate
// new child schedulers with the methods Scheduler.Go and Scheduler.GoNB.
// After creating the main Scheduler, before any call to other functions
// you HAVE to call for `go Scheduler.Start()` and then at the end call
// for `Scheduler.Stop()` in order to block and cleanup
func NewScheduler(logger Logger, name string) *Scheduler {
	return &Scheduler{
		name:          name,
		m:             new(sync.Mutex),
		panicChan:     make(chan routinePanic, 10),
		errChan:       make(chan routineError, 10),
		logWG:         new(sync.WaitGroup),
		exitC:         make(chan struct{}),
		mainScheduler: true,
		logger:        logger,
	}
}

// Start crates the loop that listens for any panic or error generated
// by the child tree, waits for all the terminations and cleans up
func (sc *Scheduler) Start() {
	go func() {
		for {
			select {
			case rPanic := <-sc.panicChan:
				if rPanic.err != nil {
					sc.logger.Log(
						LOG_LEVEL_FATAL,
						fmt.Sprintf("routine panic (%v): %v", rPanic.sc, rPanic.err),
						rPanic.stack,
					)
					sc.logWG.Done()
				}

			case rError := <-sc.errChan:
				if rError.err != nil {
					sc.logger.Log(
						LOG_LEVEL_ERROR,
						fmt.Sprintf("routine error (%v): %v", rError.sc, rError.err),
					)
					sc.logWG.Done()
				}
			}
		}
	}()

	for range sc.exitC {
	}

	// Cleanup
	close(sc.panicChan)
	close(sc.errChan)
}

// Wait waits for all routines to terminate and for all the
// logs to be handled
func (sc *Scheduler) Wait() {
	if sc.mainScheduler {
		sc.mainWait()
	} else {
		sc.childWait()
	}
}

// Stop tells the scheduler to not accept any new routine, waits for
// any existing routine to terminate and does cleanup
func (sc *Scheduler) Stop() {
	sc.m.Lock()
	sc.stopping = true
	sc.m.Unlock()

	sc.Wait()
	sc.logWG.Wait()

	close(sc.exitC)
}

// mainWait is used ONLY by the main handler after the Scheduler.Start method,
// to listen to the termination of all the child processes use the Scheduler.Wait
// method
func (sc *Scheduler) mainWait() {
	sc.m.Lock()

	var firstWait bool
	if !sc.firstWaitCalled {
		sc.firstWaitCalled = true
		firstWait = true
	}

	sc.m.Unlock()

	if !firstWait {
		fmt.Println(ChanIsOpened(sc.waitC))
		for range sc.waitC {
		}
		return
	}

	if sc.child != nil {
		sc.child.Wait()
	}

	sc.m.Lock()

	if ChanIsOpened(sc.waitC) {
		close(sc.waitC)
	}
	sc.firstWaitCalled = false

	sc.m.Unlock()
}

// This function is not called by the main Scheduler
func (sc *Scheduler) childWait() {
	sc.m.Lock()

	var firstWait bool
	if !sc.firstWaitCalled {
		sc.firstWaitCalled = true
		firstWait = true
	}

	sc.m.Unlock()

	if !firstWait {
		for range sc.exitC {
		}
		return
	}

	if sc.child != nil {
		sc.child.Wait()
	}

	close(sc.exitC)
}

// exit waits for the childs to exit (if any) and then tells the parent
// its termination. This is not called by the main scheduler
func (sc *Scheduler) exit() {
	sc.m.Lock()

	if sc.child != nil {
		sc.m.Unlock()
		sc.child.Wait()
	} else {
		sc.m.Unlock()
	}

	sc.parent.Done()
}

// RoutineFunc is the function type used for every new Routine generated.
// The parameter sc is the new child Scheduler generated by the calling one
// and can be used to generate other childs and routines. The error return value
// will be logged with the Logger of the main Scheduler is non-nil
type RoutineFunc func(routine Routine) error

// Routine is the interface implemented by the Scheduler used to hide some
// critical methods that must be called only on the main Scheduler
type Routine interface {
	Go(RoutineFunc, ...string)
	GoNB(RoutineFunc, ...string)
	Wait()
	Logger() Logger
}

// Name returns the routine identifier, that can be one of theese combinations:
//   - the name of the parent Scheduler + the name of sc (if provided when generated)
//   - the name of the parent Scheduler and annotated the depth of the tree of childs
//     starting from the last Scheduler with an explicit name
//   - a combination of the two above
func (sc *Scheduler) Name() string {
	if sc.depth == 0 {
		return sc.name
	}

	return fmt.Sprintf("%s(+%d)", sc.name, sc.depth)
}

func (sc *Scheduler) String() string {
	return sc.Name()
}

func (sc *Scheduler) Logger() Logger {
	return sc.logger
}

func (sc *Scheduler) recoverAndDefer() {
	//Recover
	if err := recover(); err != nil {
		sc.logWG.Add(1)
		sc.panicChan <- routinePanic{
			err, Stack(), sc,
		}
	}

	//Defer
	sc.exit()
}

// Stack prints the execution stack
func Stack() string {
	var out string

	split := strings.Split(string(debug.Stack()), "\n")
	cont := true

	for _, s := range split {
		if strings.HasPrefix(s, "panic(") {
			cont = false
		}

		if cont {
			continue
		}

		out += s + "\n"
	}

	return strings.TrimRight(out, "\n")
}

// newChild creates a new Scheduler child with the given name (if provided).
// An empty string as a name is considered as "non provided". See Scheduler.Name
// for the implementation details
func (sc *Scheduler) newChild(name string) *Scheduler {
	newName := sc.name

	var newDepth int
	if name != "" {
		newName += "-" + name
	} else {
		newDepth = sc.depth + 1
	}

	return &Scheduler{
		name:      newName,
		depth:     newDepth,
		m:         new(sync.Mutex),
		parent:    sc.child,
		logWG:     sc.logWG,
		exitC:     make(chan struct{}),
		panicChan: sc.panicChan,
		errChan:   sc.errChan,
		logger:    sc.logger,
	}
}

// Go creates a new routine and Scheduler with the provided name (can be omitted).
// This will create a blocking routine and the parent scheduler will wait for its
// termination
func (sc *Scheduler) Go(f RoutineFunc, name ...string) {
	sc.m.Lock()
	defer sc.m.Unlock()

	if sc.mainScheduler && sc.stopping {
		return
	}

	if sc.mainScheduler && !ChanIsOpened(sc.waitC) {
		sc.waitC = make(chan struct{})
	}

	if sc.child == nil {
		sc.child = new(sync.WaitGroup)
	}
	sc.child.Add(1)

	childSC := sc.newChild(strings.Join(name, " "))
	go childSC.goChildFunc(f)
}

// GoNB creates a new routine and Scheduler with the provided name (can be omitted).
// This will create a non-blocking routine and the parent scheduler will not wait for
// its termination
func (sc *Scheduler) GoNB(f RoutineFunc, name ...string) {
	childSC := sc.newChild(strings.Join(name, " "))
	go childSC.goChildFunc(f)
}

// goChildFunc is called when a new child is created
func (sc *Scheduler) goChildFunc(f RoutineFunc) {
	defer sc.recoverAndDefer()

	var err error
	if f != nil {
		err = f(sc)
	}
	if err != nil {
		sc.logWG.Add(1)
		sc.errChan <- routineError{err, sc}
	}
}
